package com.core.kubejselectrodynamics.block.wire;

import com.google.gson.JsonElement;
import dev.latvian.mods.kubejs.block.BlockBuilder;
import dev.latvian.mods.kubejs.registry.RegistryInfo;
import dev.latvian.mods.kubejs.util.UtilsJS;
import electrodynamics.common.block.subtype.SubtypeWire;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;

import java.util.Map;

public class BlockWireMainBuilder extends BlockWireBuilder {
    public BlockWireMainBuilder(ResourceLocation location) {
        super(location, SubtypeWire.WireColor.NONE, SubtypeWire.WireClass.BARE);
    }

    @Override
    public void createAdditionalObjects() {
        for (SubtypeWire.WireColor wireColor : SubtypeWire.WireColor.values()) {
            if (invalidColor(wireColor)) {
                continue;
            }

            for (SubtypeWire.WireClass wireClass : SubtypeWire.WireClass.values()) {
                if (mainConfiguration(wireClass)) {
                    continue;
                }

                ResourceLocation newID = newID("", getSerializedName(wireClass) + getSerializedName(wireColor));
                BlockWireBuilder builder = new BlockWireBuilder(this, newID, wireColor, wireClass);
                if (hasBaseTexture()) {
                    builder.wireTint(getWireTint().r(), getWireTint().g(), getWireTint().b(), getWireTint().a());
                }
                copyRelevantProperties(builder);
                RegistryInfo.BLOCK.addBuilder(builder);
                builder.createAdditionalObjects();
                if (displayName != null) {
                    builder.displayName(formatSubtypeName(displayName.getString(), wireColor, wireClass));
                }else {
                    builder.displayName(formatSubtypeName(UtilsJS.snakeCaseToTitleCase(id.getPath()), wireColor, wireClass));
                }
            }
        }

        if (itemBuilder != null) {
            RegistryInfo.ITEM.addBuilder(itemBuilder);
        }
    }

    // Make the new builder a copy of the current
    // this sucks
    private void copyRelevantProperties(BlockBuilder builder) {
        builder.soundType = soundType;
        builder.mapColorFn = mapColorFn;
        builder.hardness = hardness;
        builder.resistance = resistance;
        builder.lightLevel = lightLevel;
        builder.opaque = opaque;
        builder.fullBlock = fullBlock;
        builder.requiresTool = requiresTool;
        builder.renderType = renderType;
        builder.tint = tint;
        builder.model = model;
        builder.customShape = customShape;
        builder.noCollision = noCollision;
        builder.notSolid = notSolid;
        builder.slipperiness = slipperiness;
        builder.speedFactor = speedFactor;
        builder.jumpFactor = jumpFactor;
        builder.randomTickCallback = randomTickCallback;
        builder.lootTable = lootTable;
        builder.blockstateJson = blockstateJson;
        builder.modelJson = modelJson;
        builder.noValidSpawns = noValidSpawns;
        builder.suffocating = suffocating;
        builder.viewBlocking = viewBlocking;
        builder.redstoneConductor = redstoneConductor;
        builder.transparent = transparent;
        builder.instrument = instrument;
        builder.blockStateProperties = blockStateProperties;
        builder.defaultStateModification = defaultStateModification;
        builder.placementStateModification = placementStateModification;
        builder.canBeReplacedFunction = canBeReplacedFunction;
        builder.stepOnCallback = stepOnCallback;
        builder.fallOnCallback = fallOnCallback;
        builder.afterFallenOnCallback = afterFallenOnCallback;
        builder.explodedCallback = explodedCallback;
        builder.rotateStateModification = rotateStateModification;
        builder.mirrorStateModification = mirrorStateModification;
        builder.rightClick = rightClick;
        for (Map.Entry<String, JsonElement> entry : textures.entrySet()) {
            builder.textures.add(entry.getKey(), entry.getValue());
        }
    }

    // This configuration will be generated by the current, main builder,
    // so we won't bother dispatching a new builder for it
    private static boolean mainConfiguration(SubtypeWire.WireClass wireClass) {
        return wireClass == SubtypeWire.WireClass.BARE;
    }

    // In the context of colored blocks, "none" makes no sense
    private static boolean invalidColor(SubtypeWire.WireColor wireColor) {
        return wireColor == SubtypeWire.WireColor.NONE;
    }

    private static Component formatSubtypeName(String main, SubtypeWire.WireColor wireColor, SubtypeWire.WireClass wireClass) {
        String classPrefix = UtilsJS.snakeCaseToTitleCase(getSerializedName(wireClass));
        String colorPostfix = UtilsJS.snakeCaseToTitleCase(getSerializedName(wireColor));
        return Component.literal(String.format("%s %s (%s)", classPrefix, main, colorPostfix));
    }
}
